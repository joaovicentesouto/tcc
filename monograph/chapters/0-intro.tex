\chapter{Introduction}
\label{ch.intro}

% Context
% - Historical background moore:1965
% -- Frequency barrier
    % Há alguns anos atrás, era comum aumentar a frequência dos processadores para aumentar o seu poder de processamento.
    % Entretanto, pelo aumento "proporcional" da temperatura, essa prática se tornou proibitiva.
    % Por outro lado, o aperfeiçoamento constante da tecnologia de semicondutores ajudaram a amenizar o impacto dessa proibição, possibilitando construir processadores mais potentes.
    % Desta forma, conhecendo a barreira de frequência e o iminente fim da Lei de Moore~\cite{moore:1965}, a academia e a indústria começaram a pesquisar e investir em alternativas para manter o aumento do poder de processamento dos sistemas computacionais.
    For some years now, it was common to increase the frequency of processors to improve their processing power.
    However, as a side effect, the temperature rise was much higher than the performance, making this practice prohibitive.
    Alternatively, the constant improvement of semiconductor technology helped to mitigate the impact of this problem, permitting the industry to build more powerful processors with the same frequency.
    Therefore, knowing the frequency barrier and the imminent end of Moore's Law~\cite{moore:1965}, the academy and the industry began to research and invest in alternatives to keep increasing the processing power of computer systems.

% -- Improves architectural parts
    % Essas pesquisas levaram a uma grande diversidade de compensações nas arquiteturas modernas.
    % Desde o aperfeiçoamento em um único núcleo através de diferentes tipos de conjuntos de instruções, paralelismo de instruções, técnicas de processamento fora de ordem, técnicas de predição de desvios e diferentes hierarquias de memória.
    % Até o aumento do número de componentes em um único chip como núcleos de processamento, aceleradores, dispositivos de IO e, como consequência, diferentes tipos de interconexões e mecanismos de coerência de operações e de memória.
    % Onde, o principal conjunto de arquiteturas, denominada \textit{multicores}, possibilitou o aumento continuo do poder de processamento.
    Such researches have led to a wide diversity of trade-offs in modern architectures.
    For instance, different types of instruction sets, instruction parallelism, out-of-order processing techniques, detour prediction techniques, and various memory hierarchies were some of the key techniques proposed to improve the performance of a single core.
    Then, the performance of computer systems has been improved even further by increasing the number of processing cores in a single die.
    These architectures, called \textit{multicores}, allowed the continuous rise of the computing performance.

% - From multicore to manycores
    % Outro ponto que também começou a ser discutido nos últimos anos é como medimos o poder de processamento atual.
    % Usualmente, utilizava-se a quantidade de operações de ponto-flutuante por segundo (FLOP) em \hpc.
    % Contudo, o consumo de energia começou a ser outro limitador no aumento de desempenho.
    % Neste ponto, com a popularização de sistemas embarcados e para supercomputadores atingirem o poder de processamento em \exascale (10$^{18}$), computer systems must take into account their energy consumption~\cite{darpa:exascale}.
    % Therefore, a new architecture category of processors, denominated \textit{lightweight} \manycores, emerged to provide high parallelism with low-power consumption.
    However, in recent years, the energy consumption of parallel processors has become as important as their processing power, which is usually measured by the number of \textit{floating-point operations per second} (FLOPS).
    At this point, with the popularization of embedded systems as well as the aim to reach the \exascale (10$^{18}$ FLOPS), a new class of parallel processors, named \textit{lightweight} \manycores, emerged to provide high parallelism with low-power consumption.
    
% - Manycores characteristics
    The main characteristics of  lightweight \manycores are the following:
    \begin{itemize}
        \item They integrate thousands of low-power cores in a single die organized in clusters;
        \item They are designed to cope with \mimd workloads;
        \item They rely on a high-bandwidth \noc for fast and reliable message-passing communication;
        \item They present constrained memory systems; and
        \item They frequently feature a heterogeneous configuration.
    \end{itemize}
    Some industry-successful examples of lightweight manycores are
    the \mppa~\cite{DINECHIN20131654};
    the \epiphany~\cite{olofsson2014}; and
    the \taihulight~\cite{zheng2015}.

% Motivation
% - Difficults from Manycores
    Jointly with further performance scalability and energy efficiency, manycores brought a new set of challenges in software development coming from their architectural particularities.
    Precisely, these particularities introduce the following difficulties:
    \begin{itemize}
        \item \textbf{Hybrid programming model:} due to the parallel and distributed nature of the architecture, engineers are frequently required to adopt a message-passing programming model to deal with the presence of rich \nocs~\cite{kelly2013} that interconnects clusters and a shared-memory model inside the cluster.
        \item \textbf{Missing hardware support for cache coherency:} to reduce power consumption, theses processors do not feature cache coherency, which in turn forces programmers to handle it explicitly in software level and frequently calls out for a redesign in their applications~\cite{francesquini2015};
        \item \textbf{Constrained memory system:} the frequent presence of multiple physical address spaces and small local memories require data tiling and prefetching to be handled by the software~\cite{Castro2016};
        \item \textbf{Heterogeneous configuration:} the different programmable components on lightweight \manycores turns the actual deployment of applications in a complex task~\cite{barbalace2015}.
    \end{itemize}

% - Why is development on manycores difficult?
    % Parte desses desafios derivam dos sistemas operacionais e runtimes existentes.
    % Primeiramente, sistemas tradicionais, com uma visão monolítica e projetados para hardwares homogêneos, são dificilmente portados para essas novas arquiteturas.
    % O processo de paralização das estruturas internas, mudança nos paradigmas de comunicação e no uso inadequado dos recursos do hardware formentam o desenvolvimento de novos sistemas operacionais desenvolvidos do zero\cite{OSs}.
    % Por outro lado, os runtimes existentes não lidam, ou lidam parcialmente, com todos as particulatidades dos manycores.
    % Desta forma, jogando a responsabilidade para as camadas superiores, torna o processo de desenvolvimento complexo e as aplicações dependentes das arquiteturas, dificeis de manter e portar.

    % a concurrent internal structures, changing communication paradigms, and inefficient use of hardware 
    % the port of the traditional \oses with a monolithic view and designed for translate in a complicated task~\cite{Baumann2009}.

    Part of these challenges derives from existing \oses and runtimes.
    On the one hand, the complicated portability and scalability of traditional \oses with a monolithic kernels, which were designed to homogeneous hardwares, is leading to the development of new \oses from scratch~\cite{Baumann2009, kluge2014, nightingale2009, rhoden2011}.
    On the other hand, existing runtimes only partially address some of the programmability issues of lightweight \manycores, making the process of developing, porting, and maintaining applications a challenging task.

% Challenges and Problem Definition
% - How are OSs essential in this context?

% - Why these problems exist? (Because the existing OSes does not handle architecture particularities)
% - These particularities prevent common OSes that easy portated without a complex redesign. And existing OSes does not account some architectural points.

% Goals and Contributions
% - Redesign from scratch around all their tight architectural constraints.
% - Focus on addressing first-order programmability challenges
% - Introducing generic and flexible HAL for lightweight manycores
    % Nexte contexto, o doutorando e coorientador deste trabalho, Pedro H. Penna, mirando a maior programabilidade e portabilidade para lightweight manycores, propoe que sistemas operacionais para essa nova geração de processadores deve ser reprojetada do zero baseando-se em todas as suas restrições arquiteturais.
    % Sua proposta envolve um sistema operacional completo distribuido baseado em uma arquitetura multikernel~\cite{multikernel}.
    % Para isso, baseados em resultados de serviços experimentais desenvolvidos encimado do mppa256~\cite{rmem}, a pesquisa começou buscando resolver os primeiros desafios que surgiram.
    % Especificamente, foi introduzido uma \hal genérica e flexivel para lightweight manycores que lidam com os problemas chaves encontrados no desenvolvimento para esses processadores.
    % Em seguida, a pesquisa seguirá em desenvolver um microkernel para prover os mecanismos básicos para desenvolvimento de um OS completo sobre ele.
    % Por fim, o desenvolvimento de serviços do multikernel serão alcançados.

    We believe that \oses for the next-generation of lightweight \manycores must be redesigned from scratch to cope with their tight architectural constraints. Based on this idea, a new fully-featured distributed \os based on a \multikernel approach~\cite{Baumann2009} is being proposed\todo{REF Nanvix}. Nanvix features a generic and flexible \hal for \textit{lightweight} \manycores that addresses the key issues encountered in the development for these processors. This \hal is structured in two major logic layers: one that abstracts the management of a single cluster, which is named \textit{Cluster Abstraction Layer}; and another that encapsulates architectural features that spawn across multiple clusters, which is called \textit{Processor Abstraction Layer}.

    In this monograph, we intend to port the Nanvix \hal to the \mppa maycore processor\todo{REF}. This work will be done in collaboration with Pedro H. Penna, who is a Ph.D. student at the University of Grenoble Alpes, the main developer of Nanvix and the co-advisor of this work. Then, we will analyze the performance of the proposed implementation using specific micro-benchmarks.

%\section{Objectives}
%    Assist to research and develop \hal for \textit{lightweight} manycores.
%
%\subsection{General Objective}
%    On the basis of the foregoing, the following general objective and the specific objectives of this project.
%    
%\subsection{Specific Objectives}
%    \begin{itemize}
%        \item Present and discuss hal \textit{lightweight} manycores.
%        \item Design and develop the Inter-cluster communication module.
%        \item Assist in the development and improvement of other modules.
%        \item Perform a performance analysis of the proposed \hal for the \mppa.
%    \end{itemize}
    
% \section{Organization Of The Work}
%     This section is under development.