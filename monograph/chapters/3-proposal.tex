\chapter{Proposal}
\label{ch.proposal}

A proposta desta dissertação é composta por duas contribuições principais.
A primeira contribuição será o porte do modulo de comunicação entre clusters
descrito na Seção \ref{sec.inter-cluster-communication} para o processador manycore MPPA.
A segunda contribuição será o projeto e implementação de serviços de comunicação de
um sistema operacional mestre-escravo encima desse módulo de comunicação.

\section{Inter-Cluster Communication Module}

    Idealmente, a implementação da HAL não deveria utilizar nenhuma outra camada
	de software para conversar com o hardware.
	Porém, a implementação da HAL no MPPA utiliza-se de camadas indispensáveis
	da pilha de software disponibilizada pela Kalray.
	Para substituí-las seria necessário um grande esforço, fugindo da proposta
	deste trabalho e do escopo do doutorado do Pedro H. Penna.
	Os principais motivos para essa decisão foram devido a documentação pobre
	e a impossibilidade de executar código em modo kernel livremente.
	
	\begin{figure}[t]
		\centering
		\caption{Software Stack of the \mppa.}

		\includegraphics[width=.7\textwidth]{images/software-stack.png}

		Source: \mppa Processor Documentation.

		\label{fig.conpt_sync}
	\end{figure}

	A Figure X mostra a pilha de software presente para o MPPA.
	A partir dela, serão utilizados apenas o hypervisor e a biblioteca vbsp.
	O hypervisor é utilizado para virtualizar o hardware separando-o em partes lógicas,
	e.g., virtualização do núcleo, da interface cnoc e da interface dnoc.
	Ele também exporta rotinas para gerenciar, configurar e permitir acesso aos recursos virtuais.
	A biblioteca vbsp, por sua vez, prove primitivas para configuração de interrupções.

	O módulo de comunicação entre clusters utilizará interfaces da própria HAL
	e as virtualizações das interfaces cnoc e dnoc diretamente.
	As interfaces virtuais exportam chamadas assíncronas para adquirir permissão de leitura e escrita
	direta de registradores que configuram o hardware para determinada tarefa.
	Por exemplo, a configuração da DMA para envio assíncrono é abstraido por
	micro-threads que são configuradas através de estruturas globais providas pelo hypervisor.

    \begin{table}[t]
        \caption{Cluster Identification.}

        \begin{tabular}{|l|l|l|}
            \hline
                        & Physical ID & Logical ID \\ \hline
            \ccluster   & 0-15        & 0-15       \\ \hline
            \iocluster0 & 128-131     & 16-19      \\ \hline
            \iocluster1 & 192-195     & 20-23      \\ \hline
        \end{tabular}

        \label{tab.cluster-id}
    \end{table}

    Os clusters possuem dois identificadores, um físico e outro lógico.
    Os identificadores físicos são os números em hardware que identica-los
    durante o processo de roteamento dos dados através da \noc.
    Os identificadores lógicos são números associados aos identificadores
    lógicos para que seja possível identificar os clusters fora da \hal.
    Os identificadores lógicos servem principalmente para desassociar
    a identificação de um cluster da arquitetura no qual a \hal está implementada,
    como ilustrado na Tabela X.

    \begin{table}[]
        \caption{Partitions of \noc resources by abstraction.}

        \begin{tabular}{l|l|l|l|l|}
            \cline{2-5}
                                           & \multicolumn{2}{c|}{\cnoc} & \multicolumn{2}{c|}{\dnoc} \\ \cline{2-5} 
                                           & RX Slot & TX Channel & RX Slot & TX Channel \\ \hline
            \multicolumn{1}{|l|}{\mailbox} & 0-23    & 0          & 0-23    & 1-3        \\ \hline
            \multicolumn{1}{|l|}{\portal}  & 24-47   & 1-2        & 24-47   & 4-7        \\ \hline
            \multicolumn{1}{|l|}{\sync}    & 48-71   & 3          & -       & -          \\ \hline
        \end{tabular}

        \label{tab.cluster-id}
    \end{table}

    Para realizar a comunicação entre dois cluster é necessário saber
    que o emissor conheça qual o recurso que o receptor vai utilizar.
    Por este motivo, o intervalo de slot de recebimento da cnoc e dnoc
    são repartidos por abstração, como pode ser visto na Tabela A.
    Dentro de uma partição, um slot é associado a cada identificador lógico dos cluster.
    Por outro lado, os emissores utilizam canais de envio que precisam
    ser reservados durante toda a operação, para isso, a Tabela A também mostra
    a partição dos canais para cada abstração.

\subsection{Sync}

% \todo[inline]{
%     Quais são as funções?
%     Como pretendes implementá-las?
%     Quais são os recursos (API ou hardware) do MPPA que serão
%     explorados para implementar essa interface?
% }

\begin{figure}[t]
\begin{lstlisting}[
    caption=HAL Sync Interface for Receiver Cluster,
    label=cod:sync-receiver,
]
    /* @brief Allocates and configures the receiving side of
     *        the synchronization point.                     */
    int sync_create(const int *nodes, int nnodes, int type);

    /* @brief Releases and cleans receiver buffer. */
    int sync_unlink(int syncid);

    /* @brief Wait signal on a specific synchronization point. */
    int sync_wait(int syncid);
\end{lstlisting}
\end{figure}

\begin{figure}[t]
\begin{lstlisting}[
    caption=HAL Sync Interface for Sender Cluster,
    label=cod:sync-sender,
]
    /*  @brief Allocates and configures the sending side of
     *  the synchronization point.                          */
    int sync_open(void);

    /* @brief Releases the sender resources on a specific DMA channel. */
    int sync_close(int syncid);

    /* @brief Send signal on a specific synchronization point. */
    int sync_signal(int syncid, const int *nodes, int nnodes, int type);
\end{lstlisting}
\end{figure}

    A abstração \sync pode ser decomposta em dois conjuntos de funções, um para
    os clusters que irão receber sinais e outro para os que irão enviar.
    Cada conjunto aloca tipos diferentes de recursos.
    O receptor deverá alocar um slot de recebimento da cnoc.
    Pelo contrário, o emissor alocará um canal de emissão da cnoc.
    Devido a isso, serão exportados 24 pontos de recebimento de sinal,
    um para cada identificador lógico, e 1 ponto de envio de sinal.

    As funções implementam dois tipos diferentes dependendo de quem
    deve ser o mestre da operação de sincronização.
    Isto é, toda operação de sincronização é separada em um cluster mestre
    e um ou mais clusters escravos, definidas pelas constantes
    \texttt{ONE\_TO\_ALL} e \texttt{ALL\_TO\_ONE}.
    O mestre sempre assume o papel "ONE" e os escravos o papel "ALL".
    As subseções abaixo descreveram o comportamento e detalhes de implementação
    de cada um dos tipos de sincronização.

        \subsubsection*{\texttt{ONE\_TO\_ALL} Synchronization Type}

            Os clusters escravos envolvidos neste tipo de sincronização esperam
            um sinal enviado do mestre.
            Para isso, cada escravo executará a função \texttt{sync\_create()}
            alocando o recurso associado ao identificador lógico do mestre.
            Após alocar e configurar o recurso, o cluster pode continuar
            executando sem se preocupar se o sinal foi recebido.
            Quando chegar a hora de realizar a sincronização, basta o escravo
            escutar a função \texttt{sync\_wait()}.
            Ao receber o sinal, o sync autoreconfigurará o recurso e liberará o cluster,
            caso ele esteja esperando.

            O mestre, por sua vez, deverá executar as funções complementares.
            Isto é, primeiramente, o mestre alocará um recurso de envio
            ao chamar a função \texttt{sync\_open()}.
            Após isso, ele deverá informar o conjunto de clusters que
            receberão o sinal para o seu identificador lógico.
            Por fim, ambos podem chamar as funções de liberação dos recursos
            de sincronização, \texttt{sync\_unlink()} para o escravo e
            \texttt{sync\_close()} para o mestre.

        \subsubsection*{\texttt{ALL\_TO\_ONE} Synchronization Type}

            Analogamente ao tipo anterior, apenas os papeis se invertem.
            O mestre deverá executar as funções de criação, configuração dos
            recursos e espera dos inúmeros sinais.
            O recurso alocado pelo mestre deverá ser o recurso associado ao
            seu próprio identificador lógico.
            Por outro lado, os escravos executarão as funções de abertura
            e envio de um sinal para o indentificador lógico do mestre.

\subsection{Mailbox}

% \todo[inline]{
%     Quais são as funções?
%     Como pretendes implementá-las?
%     Quais são os recursos (API ou hardware) do MPPA que serão
%     explorados para implementar essa interface?
% }

\begin{figure}[t]
\begin{lstlisting}[
    caption=HAL Mailbox Interface for Receiver Cluster,
    label=cod:mailbox-receiver,
]
	/* @brief Creates a mailbox. */
	int mailbox_create(int nodenum);

	/* @brief Destroys a mailbox. */
	int mailbox_unlink(int mbxid);

    /* @brief Reads data from a mailbox. */
	ssize_t mailbox_read(int mbxid, void * buffer, size_t size);
\end{lstlisting}
\end{figure}

\begin{figure}[t]
\begin{lstlisting}[
    caption=HAL Mailbox Interface for Sender Cluster,
    label=cod:mailbox-sender,
]
    /* @brief Opens a mailbox. */
	int mailbox_open(int nodenum);

	/* @brief Closes a mailbox. */
	int mailbox_close(int mbxid);

	/* @brief Writes data to a mailbox. */
	ssize_t mailbox_write(int mbxid, const void * buffer, size_t size);
\end{lstlisting}
\end{figure}

\subsection{Portal}

\todo[inline]{Quais são as funções? Como pretendes implementá-las? Quais são os recursos (API ou hardware) do MPPA que serão explorados para implementar essa interface?}

\begin{figure}[t]
\begin{lstlisting}[
    caption=HAL Portal Interface for Receiver Cluster,
    label=cod:portal-receiver,
]
	/* @brief Creates a portal. */
    int portal_create(int local);

	/* @brief Destroys a portal. */
    int portal_unlink(int portalid);

    /* @brief Allow sender to transfer data. */
    int portal_allow(int portalid, int remote);

    /* @brief Reads data from a portal. */
    ssize_t portal_read(int portalid, void * buffer, size_t size);

    /* @brief Reads data asynchronously from a portal. */
    ssize_t portal_aread(int portalid, void * buffer, size_t size);

    /* @brief Waits for an asynchronous operation on a
     *        portal to complete.                      */
    int portal_wait(int syncid);
\end{lstlisting}
\end{figure}

\begin{figure}[t]
\begin{lstlisting}[
    caption=HAL Portal Interface for Sender Cluster,
    label=cod:portal-sender,
]
    /* @brief Opens a portal. */
    int portal_open(char *);

	/* @brief Closes a portal. */
    int portal_close(int);

	/* @brief Writes data to a portal. */
    ssize_t portal_write(int, const void *, size_t);

    /* @brief Writes data asynchronously to a portal. */
    int portal_awrite(int, const void *, size_t);
    
    /* @brief Waits for an asynchronous operation on a
     *        portal to complete.                      */
    int portal_wait(int syncid);
\end{lstlisting}
\end{figure}

\section{Communication Services}

\todo[inline]{
    Quais são os serviços?
    Como pretendes implementá-los?
    Quais são os recursos (API ou hardware) do MPPA que serão explorados
    para implementar esses serviços?
}
