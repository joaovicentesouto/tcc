\chapter{Introduction}
\label{ch.intro}

	% Context
	% Historical background
	% Frequency barrier
	For several years, the increase in the frequency of processors was
	employed as the main technique for achieving performance
	improvements. However, as a side effect, the temperature of
	processors started rising to high values, thus imposing a physical
	limit to the aforementioned technique.  Alternatively, the constant
	improvement of semiconductor technology helped to mitigate the
	impact of this problem, allowing the industry to build more powerful
	processors with the same frequency.  Therefore, knowing the
	frequency barrier and the imminent end of Moore's
	Law~\cite{moore:1965}, the academy and industry began to research
	and invest in alternatives to keep increasing the processing power
	of computer systems.

	% Improves architectural parts
	These researches led to a wide diversity of trade-offs in modern
	architectures.  For instance, different types of instruction sets,
	instruction parallelism, out-of-order processing techniques, branch
	prediction techniques, and various memory hierarchies were some of
	the key techniques proposed to improve the performance of a single
	core.  Then, the performance of computer systems was pushed even
	further by increasing the number of processing cores in a single
	die. These architectures, called \textit{multicores}, allowed the
	continuous rise of the computing performance.

	\todo[inline]{Acho que seria legal usar a figura para deixar mais
		claro o texto nos dois último parágrafos.}

	The ever-increasing number of transistors and cores in a chip
	quickly lead to the advent of \manycores.  Notwithstanding, the line
	between \textit{multicores} and \manycores is very tenuous.  Some
	researchers argue that the in latter architectures, losing a core it
	will not significantly impact the performance of the platform.  A
	system is classified as \manycore when there is a need for
	distributed memory and on-chip networking~\cite{freitas:thesis}.

	\begin{figure}[t]
		\centering%
		\caption{42 years of Multiprocessor Trend Data.}%
		\label{fig:microprocessor-data}%
		\includegraphics[width=.85\textwidth]{42-years-processor-trend.pdf}%
		\fonte{\citeonline{url:microprocessor-trend-data}.}%
	\end{figure}

	% From multicore to manycores and Manycores characteristics
	Yet another classification for manycores is based on
	their ratio between processing power (\flops) and power consumption
	(\watts), as shown in \autoref{fig:microprocessor-data}.  For
	instance, to achieve \exascale (10$^{18}$ \flops), the US Department
	of Defense issued a report stipulating the energy efficiency of a
	supercomputer should be around 50
	GFLOPS/\watts~\cite{darpa:exascale}.  Recently, a new class of
	parallel processors, called \lightweight \manycores, emerged to
	provide high parallelism with low power consumption.  These
	processors own the following characteristics:

	\begin{itemize}
		\item Integrate thousands of low-power cores in a single die organized in clusters;
		\item Are designed to cope with Multiple Instruction Multiple
		Data (MIMD\todo{adicionar acronym para mmid}) workloads;
		\item Rely on a high-bandwidth \noc for fast and reliable message-passing communication;
		\item Present constrained memory systems; and
		\item Frequently feature a heterogeneous configuration.
	\end{itemize}

	\todo[inline]{Qual a diferenca entre manycores e lightweight
		manycores? Nao ficou muito clara a transicao de manycores para
			lightweight manycores. Talvez a ideia seria de deixar bem
			claro o contraponto. ex: Lightweight manycores differ from
			traditional large-scale multicores and manycores in several
			points: <listar as diferencas>}


	Some industry-successful examples of \lightweight \manycores are the
	\mppa~\cite{DeDinechin2013-1}; the \epiphany~\cite{olofsson2014};
	and the \taihulight~\cite{zheng2015}.  Together with superior performance
	scalability and energy efficiency, lightweight manycores brought a new
	set of challenges in software development coming from their
	architectural particularities.  More precisely, these 
	introduced the following difficulties:

	\begin{itemize}
		\item \textit{Hybrid programming model:} due to the parallel and
		distributed nature of the architecture, engineers are frequently
		required to adopt a message-passing programming model to deal
		with the presence of rich \nocs~\cite{kelly2013} that
		interconnects clusters and a shared-memory model inside the
		cluster.

		\item \textit{Missing hardware support for cache coherency:} to
		reduce power consumption, theses processors do not feature cache
		coherency, which in turn forces programmers to handle it
		explicitly in software level and frequently calls out for a
		redesign in their applications~\cite{francesquini2015};

		\item \textit{Constrained memory system:} the frequent presence
		of multiple physical address spaces and small local memories
		require data tiling and prefetching to be handled by the
		software~\cite{Castro2016};

		\item \textit{Heterogeneous configuration:} the different
		programmable components on \lightweight \manycores turns the
		actual deployment of applications in a complex
		task~\cite{barbalace2015}.
	\end{itemize}

	% Challenges and Problem Definition
	Part of these challenges derive from existing runtimes and \oss.
	On one hand, runtimes do not hide the characteristics of hardware
	making software development more challenging and nonportable, \eg do
	not allow direct access to non-local data, nor the manipulation of
	them in a transparent way.  Thus, fundamental \os mechanisms, such
	as core multiplexing, core partitioning, and process and data
	migration, may not be addressed.  On the other hand, the complicated
	portability and scalability of traditional \oss with a monolithic
	kernels, which were designed to homogeneous hardware, is leading to
	alternative \os designs~\cite{Baumann2009, kluge2014,
		nightingale2009, rhoden2011}.

	% Goals and Contributions
	We believe that \oss for the next-generation of \lightweight
	\manycores must be redesigned from scratch to cope with their tight
	architectural constraints.  Based on this idea, a new fully-featured
	distributed \os based on a multikernel approach~\cite{Baumann2009}
	is under investigations~\cite{penna2017-1,penna2017-2,penna2019}.
	The \nanvix \multikernel features a generic and flexible \hal for
	\lightweight \manycores that addresses the key issues encountered in
	the development for these processors.  On top of the \nanvix
	\textit{\hal}, we are simultaneously designing and implementing a
	microkernel that provides bare bones system abstractions for each
	cluster.

\section{Goals}
\label{sec.goals}

	Based on the aforementioned motivations, the primary and specific
	goals of this work are detailed next.

\subsection{General Goals}
\label{sec.goals.general}

	The main goal of this undergraduate dissertation is to propose a
	\textit{Inter-Cluster Communication Module} to the \nanvix
	\textit{\hal} and port it to the \mppa manycore
	processor~\cite{DeDinechin2013-1}.  This module exposes the
	essential abstractions that allow overlying layers to create richer
	communication services.  Using this module, we also
	propose \textit{Inter-Cluster Communication Services} to the \nanvix
	\microkernel.  This work was carried out in collaboration with Pedro
	Henrique Penna, who is ia Ph.D. candidate at the University of
	Grenoble Alpes (UGA), main engineer of Nanvix and co-advisor of this
	work.

	\todo[inline]{Acho que ao inves de falar que o trabalho foi
	desenvolvido comigo, dizer que está inserido em um contexto
	maior, onde a UFSC, PUC Minas e UGA trabalham juntos no
	projeto}.

\subsection{Specific Goals}
\label{sec.goals.specific}

	\begin{itemize}
		\item Propose an Inter-Cluster Communication interface for
		lightweight manycores;
		
		\item Implement the proposed interface in the \hal of Nanvix
		for the \textit{\mppa manycore processor};
		
		\item On top of the Inter-Cluster Communication interface,
		propose a Communication Service for a microkernel-based \os.
		
		\item Implement and integrate the proposed Communication Service
		int the Nanvix Microkernel;

		\item Evaluate the performance of the proposed Communication
		Services using synthetic micro-benchmarks that reproduce
		collective communication routines of the \mpi.
	\end{itemize}


	\todo[inline]{%
		Na minha visão, as contribuições podem ser quebradas em 5: (i)
		definicao e proposta de uma inteface no nivel da HAL, (ii)
		implementacao dessa interface na HAL; (iii) integracao dessa
		interface no microkernel; (iv) avaliacao de desemepenho da
		implementacao feita.
	}

\section{Organization Of The Work}
\label{sec.organization}
	
	The remainder of this work is organized as follows.
	\autoref{ch.fundamentation} details the background of this work.
	\autoref{ch.related-work} discusses the principal related work.
	\autoref{ch.development} presents the development of this work.
	\autoref{ch.experiments} describes the experiments accomplished and
	discusses the results.  Finally, \autoref{ch.conclusions} outlines
	the main conclusions of this work.
