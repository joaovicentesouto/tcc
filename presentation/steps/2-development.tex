\section{Development}

	\subsection{Low-Level Communication}

		\begin{frame}[fragile]{Inter-Cluster Communication Interface}

			\begin{itemize}
				\item Three communication abstractions:
				\begin{itemize}
					\item \textit{Sync}
					\item \textit{Mailbox}
					\item \textit{Portal}
				\end{itemize}
				\item More precise
				\item Easy-to-use
				\item Scalable
				\item Easily portable
			\end{itemize}

			% \textit{\nanvixhal} provides the inter-cluster communication module to allow separate
			% clusters to exchange information.
			% This module consists of three abstractions, named \sync, \mailbox, and \portal.
			% These abstractions provide more precise, easy-to-use, scalable, and easily
			% portable mechanisms for different architectures~\cite{wentzlaff_fleets:_2011}.
			% On top of them, it is possible to create simple facilities, such
			% as those for synchronization and data exchange, as well as more elaborate services
			% like \shm, \posix Semaphores, and \rmem~\cite{penna:rmen}.
		\end{frame}

		% \pholder[Interrup System and DMA mediator]{MPPA-256 Hardware Resources}
		\begin{frame}[fragile]{MPPA-256 Hardware Features}
			\begin{itemize}
				\item Low-level communication depends on \textbf{two features}
				\begin{itemize}
					\item Interrupt System
					\item DMA mediation
				\end{itemize}
				\item \textbf{Explicit handler} the NoC interrupts % to identify the resource
				\item \textbf{DMA limitations}
			\end{itemize}
		\end{frame}

		% \pholder{Noc Identifiers}
		\begin{frame}[fragile]{Noc Identifiers}
			\begin{itemize}
				\item NoC interfaces have \textbf{two identifiers}
				\begin{itemize}
					\item Physical ID
					\item Logical ID
				\end{itemize}
			\end{itemize}

			\begin{table}
				\centering%
				\begin{tabular}{l|l|l|}
					\cline{2-3}
											            & \textbf{Physical ID} & \textbf{Logical ID} \\ \hline
					\multicolumn{1}{|l|}{\textbf{IO 0}} & 128-131              & 0-3                 \\ \hline
					\multicolumn{1}{|l|}{\textbf{IO 1}} & 192-195              & 4-7                 \\ \hline
					\multicolumn{1}{|l|}{\textbf{CCs}}  & 0-15                 & 8-23                \\ \hline
				\end{tabular}
			\end{table}
		\end{frame}

		% \pholder{Resource Identifiers}
		\begin{frame}[fragile]{Resource Identifiers}
			\begin{itemize}
				\item Abstractions need to know \textbf{resource ID}
				\item Communication resources are \textbf{partitioned by abstraction}
			\end{itemize}

			\begin{table}[!tb]
				\centering%
				\begin{tabular}{l|l|l|l|l|}
					\cline{2-5}
														   & \multicolumn{2}{c|}{\textbf{CNoC}}               & \multicolumn{2}{c|}{\textbf{DNoC}}           \\ \cline{2-5}
														   & \textbf{RX ID} & \textbf{TX ID} & \textbf{RX ID} & \textbf{TX ID} \\ \hline
					\multicolumn{1}{|l|}{\textbf{Mailbox}} & 0-23           & 0              & 0-23           & 1-3            \\ \hline
					\multicolumn{1}{|l|}{\textbf{Portal}}  & 24-47          & 1-2            & 24-47          & 4-7            \\ \hline
					\multicolumn{1}{|l|}{\textbf{Sync}}    & 48-71          & 3              & -              & -              \\ \hline
				\end{tabular}
			\end{table}
		\end{frame}

		% \pholder[Lazy transfer and Interface convention]{General Concepts of Comm. Abstrations}
		\begin{frame}[fragile]{General Concepts of Comm. Abstrations}
			\begin{itemize}
				\item Master core \textbf{cannot be blocked}
				\item Communication Interfaces export \textbf{only asynchronous calls}
				\item \textbf{Lazy transfer algorithm}
			\end{itemize}

			\begin{itemize}
				\item \textbf{Naming Convention}
				\begin{itemize}
					\item Sender Role: \texttt{open}/\texttt{close}/\texttt{awrite/signal}/\texttt{wait}.
					\item Receiver Role: \texttt{create}/\texttt{unlink}/\texttt{aread}/\texttt{wait}
				\end{itemize}
			\end{itemize}
			% The microkernel specifically assigns the master core the task
			% of handling requests (\ie kernel calls) from slave cores. Therefore,
			% interfaces export only asynchronous calls. This decision forces
			% the upper layer, if desired, to create synchronous calls that
			% call the wait function right after the asynchronous operation.
			% Thus, at the microkernel level, we can ensure that the master core
			% sets or executes asynchronous functions and notifies blocked slaves.

			% \autoref{alg:lazy-transfer} illustrates the behavior of
			% lazy transfer, the algorithm defines that the master saves the
			% parameters of transmission if it does not have desired permission
			% and will accomplish other requests. Upon receiving permission
			% from the receiver, the interrupt handler identifies the resource,
			% actually sends the data and releases the slave that requested the
			% send. This algorithm ensures that the master is always doing useful
			% operations and never crashes the entire system.

			% Finally, abstract interfaces follow a convention to distinguish
			% between receiver and sender roles. Receivers use functions with
			% \texttt{create}, \texttt{unlink}, \texttt{aread}, and \texttt{wait}
			% suffixes. Senders, in turn, use functions with \texttt{open},
			% \texttt{close}, \texttt{awrite/signal}, and \texttt{wait} suffixes.
			% Because the \texttt{wait} function is shared, the abstraction must
			% distinguish the role by the resource identifier. Discriminating the
			% nature of operations helps both the user, being entirely intuitive,
			% and implementing \hal by explaining what features will be needed.
		\end{frame}

		% \pholder[Concept]{Sync Abstration Concept}
		\begin{frame}[fragile]{Sync Abstration}
			\begin{overprint}
			\only<1>{
				\begin{itemize}
					\item Provides cluster synchronization across \textbf{distributed barriers}
					\item Analogous to \textbf{POSIX Signals}
					\item Two modes
					\begin{itemize}
						\item \textbf{\texttt{ALL\_TO\_ONE}}
						\item \texttt{ONE\_TO\_ALL}
					\end{itemize}
				\end{itemize}
				\addfig[][width=.6\linewidth]{imgs/sync-all-to-one.pdf}
			}
			\only<2>{
				\begin{itemize}
					\item Provides cluster synchronization across \textbf{distributed barriers}
					\item Analogous to \textbf{POSIX Signals}
					\item Two modes
					\begin{itemize}
						\item \texttt{ALL\_TO\_ONE}
						\item \textbf{\texttt{ONE\_TO\_ALL}}
					\end{itemize}
				\end{itemize}
				\addfig[][width=.6\linewidth]{imgs/sync-one-to-all.pdf}
			}
		\end{overprint}

			% \textit{Synchronization Abstraction}, called \sync, provides the
			% basis for cluster synchronization across distributed barriers.
			% Its behavior is analogous to \posix Signals abstraction, but
			% notifications do not carry information, they are only for synchronization.
			% \sync defines two synchronization modes, \texttt{ALL\_TO\_ONE} and
			% \texttt{ONE\_TO\_ALL}. In both modes, there is a single master node
			% (\texttt{ONE}) and one or more slave nodes
			% (\texttt{ALL}) involved in the communication. \autoref{fig:sync-all-to-one} illustrates the
			% \texttt{ALL\_TO\_ONE} mode, where the master node waits blocked for
			% the $N$ notifications coming from the slaves. In contrast,
			% \autoref{fig:sync-one-to-all} pictures the \texttt{ONE\_TO\_ALL} mode,
			% where the master notifies the $N$ slaves, releasing them from the lock.
			% The sender nodes are responsible for sending a signal and will never
			% block. Receiver nodes are responsible for waiting for all notifications
			% to arrive.
		\end{frame}

		% \pholder[Implementation]{Sync Abstration Implementation}
		\begin{frame}[fragile]{Sync Abstration Implementation}
			\begin{itemize}
				\item Parameters required
				\begin{itemize}
					\item Node list
					\item List size
					\item Mode
				\end{itemize}
				\item Master node must be the first on the list
				\item RX resources related to the Master ID
			\end{itemize}

			\addfig[][width=.6\linewidth]{imgs/sync-all-to-one.pdf}
		\end{frame}

		% \pholder[Concept]{Mailbox Abstration Concept}
		\begin{frame}[fragile]{Mailbox Abstration}
			\begin{itemize}
				\item Allows exchange \textbf{fixed-length message}
				\item Similarly to \textbf{POSIX Message Queue}
				\item Receiver allocates space to N messages
				\item Sender transfer to predefined location
			\end{itemize}

			\addfig[][width=.4\linewidth]{mailbox-concept.pdf}		

			% \textit{Message Queue Abstraction}, called \mailbox, allows clusters to exchange
			% fixed-length messages with each other. The message size is designed to be
			% relatively small, usually a few hundreds of bytes. The recipient consumes these
			% messages without needing to know who sent them. Similarly, mailbox operations
			% follow the behavior of the \posix message queue. \autoref{fig:mailbox-concept}
			% conceptually illustrates one of the ways to implement a \mailbox. The receiver
			% allocates enough space to receive one message from each possible sender.
			% The sender transfers the message to a predefined location.

			% \autoref{fig:mailbox-flow} outlines the communication flow between a
			% receiver and a sender node. The receiver creates an empty message queue
			% where senders are free to send the first message. Subsequently, to
			% avoid overwriting old messages, all transmissions require the permission
			% of the receiver. For this reason,  when the receiver consumes a message,
			% it copies the message to the user buffer, releases the queue space, and
			% notifies the sender.
		\end{frame}

		% \pholder[Implementation]{Mailbox Abstration Implementation}
		\begin{frame}[fragile]{Mailbox Abstration Implementation}
			\begin{itemize}
				\item Parameters required for Receiver
				\begin{itemize}
					\item Create: Local node ID
					\item Read: Pointer and size of the buffer
				\end{itemize}
				\item Parameters required for Sender
				\begin{itemize}
					\item Open: Target node ID
					\item Write: Pointer and size of the buffer
				\end{itemize}
			\end{itemize}

			\addfig[][width=.75\linewidth]{mailbox-flow.pdf}	
		\end{frame}

		% \pholder[Concept]{Portal Abstration Concept}
		\begin{frame}[fragile]{Portal Abstration}
			\begin{itemize}
				\item Allows exchange \textbf{arbitrary amounts of data} between two nodes
				\item Similarly to \textbf{POSIX Pipes}
				\item \textbf{One-way} channel for data transfer
			\end{itemize}

			\addfig[][width=.4\linewidth]{portal-concept.pdf}		

			% Finally, \textit{Portal Abstraction} allows two nodes to exchange arbitrary
			% amounts of data. \autoref{fig:portal-concept} presents the conceptual idea
			% of the \portal, which resembles that of \posix Pipes with flow control.
			% The cardinality of operations is always $1:1$, where a pair of nodes opens
			% a one-way channel for data transfer. However, unlike \posix Pipes, which
			% defines that the pipe exists only between two processes, the \portal allows
			% the receiver to communicate with other nodes through the same channel.
			% The sender, in turn, can only communicate with one node.
		\end{frame}

		% \pholder[Implementation]{Portal Abstration Implementation}
		\begin{frame}[fragile]{Portal Abstration Implementation}
			\begin{itemize}
				\item Parameters required for Receiver
				\begin{itemize}
					\item Create: Local node ID
					\item Allow: Target node ID
					\item Read: Pointer and size of the buffer
				\end{itemize}
				\item Parameters required for Sender
				\begin{itemize}
					\item Open: Local and target node ID
					\item Write: Pointer and size of the buffer
				\end{itemize}
			\end{itemize}

			\addfig[][width=.75\linewidth]{portal-flow.pdf}

			% \autoref{fig:portal-flow} outlines the flow control of the \portal.
			% When attempting to transmit data to the receiver, the sender will block
			% until the receiver can accept it. By enabling one data exchange at a time,
			% the receiver configures the read settings and notifies the sender. In this way,
			% the flow control ensures that the receiver will not be overloaded, will
			% not receive data without properly configured \dma, and will not overwrite
			% previous data. Allowing communication empowers the receiver to choose which
			% communications to prioritize.	
		\end{frame}

	\subsection{User-Level Communication}

		\begin{frame}[fragile]{Integration with Nanvix Microkernel}
			\begin{itemize}
				\item Nanvix HAL does not provide \textbf{rich management} of the exposed abstractions
				\item Nanvix Microkernel seek \textbf{to provide Inter-Process Communication} between clusters
				\begin{itemize}
					\item Protection
					\item Management
					\item Manipulating
				\end{itemize}
			\end{itemize}

			% The inter-cluster communication module, described in \autoref{sec.low-level-comm},
			% is designed to export a standard and straightforward communication
			% primitives to different lightweight manycores.
			% These primitives can be used by various types of \oss and applications.
			% Thus, the module is flexible enough not to impact the performance
			% of the upper layers negatively.
			% For this, it does not provide rich management of the exposed abstractions.

			% In this scenario, the communication services of \nanvixmicrokernel seek
			% to provide \ipc between distinct clusters.
			% Specifically, these services perform the multiplexing of the hardware
			% resources and the verification of the parameters that will be passed
			% on the communication primitives.
			% Due to the Master-Slave model, the master core is responsible of protecting,
			% manipulating, and configuring \hal resources.
			% The slave core will request operations through the kernel call interface,
			% passing the necessary information to the master.
		\end{frame}

		% \pholder{Impacts of the Master-Slave Model}
		\begin{frame}[fragile]{Impacts of the Master-Slave Model}
			\begin{itemize}
				\item Only the master core manipulates internal structures of the OS
				\item Kernel call interface
				\begin{itemize}
					\item Master calls: \texttt{kernel\_\textit{abstraction}\_\textit{operation}}
					\item Slave calls: \texttt{k\textit{abstraction}\_\textit{operation}}
				\end{itemize}
				\item Slave only reads locks address from internal structures to block
			\end{itemize}

			% Master-Slave model defines that the master core must exclusively manipulate
			% the internal structures of the \os. For this end, each service has generic and
			% simple structures that hold control flags, parameters for resource
			% identification, and storage of physical descriptors returned by \hal. Thus,
			% the kernel call interface separates the functions of the services into two
			% sets of functions. The first set contains the kernel calls that request a particular
			% operation. The second set contains functions that operate on the internal structures
			% and communicate with the \hal level. The master executes almost exclusive
			% the second set, except for the wait functions, which the slave performs entirely.
		\end{frame}

		% \pholder[Protection and Management, Multiplexing, Validation and Correctness Tests]{Details}
		\begin{frame}[fragile]{Protection and Management}
			\begin{itemize}
				\item Only master core manipulates internal structures of the OS
				\item Kernel call interface
				\begin{itemize}
					\item Master calls: \texttt{kernel\_\textit{abstraction}\_\textit{operation}}
					\item Slave calls: \texttt{k\textit{abstraction}\_\textit{operation}}
				\end{itemize}
				\item Slave only reads locks address from internal structures to block
			\end{itemize}
		\end{frame}

		\begin{frame}[fragile]{Multiplexing}
			\begin{itemize}
				\item Only master core manipulates internal structures of the OS
				\item Kernel call interface
				\begin{itemize}
					\item Master calls: \texttt{kernel\_\textit{abstraction}\_\textit{operation}}
					\item Slave calls: \texttt{k\textit{abstraction}\_\textit{operation}}
				\end{itemize}
				\item Slave only reads locks address from internal structures to block
			\end{itemize}
		\end{frame}

		\begin{frame}[fragile]{Validation and Correctness Tests}
			\begin{itemize}
				\item Only master core manipulates internal structures of the OS
				\item Kernel call interface
				\begin{itemize}
					\item Master calls: \texttt{kernel\_\textit{abstraction}\_\textit{operation}}
					\item Slave calls: \texttt{k\textit{abstraction}\_\textit{operation}}
				\end{itemize}
				\item Slave only reads locks address from internal structures to block
			\end{itemize}
		\end{frame}

% LocalWords:  template cls standalone GitHub Overleaf bugfixes SVGs
% LocalWords:  Re-empacotamento fontsize Makefile pdflatex imgs PDFs
% LocalWords:  shell-escape frames SVG brazil english lapesd-slides
% LocalWords:  disabletodonotes todonotes TODO's backup showbackup
% LocalWords:  hidebackup abntexcite abntex natbib nobib titleframe
% LocalWords:  frame showsections sidebar stopcountingframes default
% LocalWords:  thanksframe Thank You Questions referencesframe titulo
% LocalWords:  bibfiles pholder todonote placeholder inline addfig
% LocalWords:  opts graphicx addfiglw width Citations dijkstra Direct
% LocalWords:  Closure Parallel dynamic scheduling DoImportantStuff
% LocalWords:  lccp merged cell svg pdf
