\section{Development}

	\subsection{Low-Level Communication}

		\begin{frame}[fragile]{Inter-Cluster Communication Interface}

			\begin{itemize}
				\item Three communication abstractions:
				\begin{itemize}
					\item \textit{Sync}
					\item \textit{Mailbox}
					\item \textit{Portal}
				\end{itemize}
				\item More precise
				\item Easy-to-use
				\item Scalable
				\item Easily portable
			\end{itemize}

			% A Interface de Comunicação entre Clusters proposta provê 3 abstrações, sync, mailbox e portal.
			% Essas abstrações buscam ser mais precisas, mais fáceis de usar, escalonáveis e facilmente portáveis.

			% %%%%%% Sobre elas é possível desenvolver serviços mais complexos.
		\end{frame}

		% \pholder[Interrup System and DMA mediator]{MPPA-256 Hardware Resources}
		\begin{frame}[fragile]{MPPA-256 Hardware Features}
			\begin{itemize}
				\item Low-level communication depends on \textbf{two features}
				\begin{itemize}
					\item Interrupt System
					\item DMA
				\end{itemize}
				\item \textbf{Explicit handler} the NoC interrupts % to identify the resource
				\item \textbf{DMA limitations}
			\end{itemize}

			A comunicação da HAL no MPPA-256 depende de duas características.
			O sistema de interrupções no qual é essencial para a configuração de interrupções provenientes da comunicação.
			Onde o mestre, ao ser notificado de uma interrupção, deve trata-la e identificar manualmente o recurso que a gerou.
			E a DMA, realiza o papel de mediador das comunicações. Entretanto, deviado a falta de documentação e exemplos, o uso da DMA é limitado a apenas realizar recebimento de forma assíncrona.
		\end{frame}

		% \pholder{Noc Identifiers}
		\begin{frame}[fragile]{NoC Identifiers}
			\begin{itemize}
				\item NoC interfaces have \textbf{two identifiers}
				\begin{itemize}
					\item Physical ID
					\item Logical ID
				\end{itemize}
			\end{itemize}

			\begin{table}
				\centering%
				\begin{tabular}{l|l|l|}
					\cline{2-3}
											            & \textbf{Physical ID} & \textbf{Logical ID} \\ \hline
					\multicolumn{1}{|l|}{\textbf{IO 0}} & 128-131              & 0-3                 \\ \hline
					\multicolumn{1}{|l|}{\textbf{IO 1}} & 192-195              & 4-7                 \\ \hline
					\multicolumn{1}{|l|}{\textbf{CCs}}  & 0-15                 & 8-23                \\ \hline
				\end{tabular}
			\end{table}

			% As interface NoC na HAL possuem dois identificadores.
			% O identificador físico é definido pelo próprio MPPA-256, o utilizando para rotear as comunicações através da NoC.
			% Para eliminar a dependência do identificador físico, foi criado um mapeamento para um identificador lógico, o qual é utilizado pelas abstrações fora da HAL.
		\end{frame}

		% \pholder{Resource Identifiers}
		\begin{frame}[fragile]{Resource Identifiers}
			\begin{itemize}
				\item Abstractions need to know \textbf{resource ID}
				\item Communication resources are \textbf{partitioned by abstraction}
			\end{itemize}

			\begin{table}[!tb]
				\centering%
				\begin{tabular}{l|l|l|l|l|}
					\cline{2-5}
														   & \multicolumn{2}{c|}{\textbf{CNoC}}               & \multicolumn{2}{c|}{\textbf{DNoC}}           \\ \cline{2-5}
														   & \textbf{RX ID} & \textbf{TX ID} & \textbf{RX ID} & \textbf{TX ID} \\ \hline
					\multicolumn{1}{|l|}{\textbf{Mailbox}} & 0-23           & 0              & 0-23           & 1-3            \\ \hline
					\multicolumn{1}{|l|}{\textbf{Portal}}  & 24-47          & 1-2            & 24-47          & 4-7            \\ \hline
					\multicolumn{1}{|l|}{\textbf{Sync}}    & 48-71          & 3              & -              & -              \\ \hline
				\end{tabular}
			\end{table}

			% Por outro lado, para prover transparência da comunicação das abstrações, é necessário que ela conheçam o recursos destino.
			% Para isso, os recursos de comunicação foram particionados por abstração.
			% Onde, dependendo dos nós envolvidos, é possível inferir os identificadores dos recursos.
			
			% %%%%%%Por exemplo, cada nó possui um slot de recebimento de dados na mailbox, permitindo que qualquer nó saiba o par interface, recurso que devem enviar os dados.
		\end{frame}

		% \pholder[Lazy transfer and Interface convention]{General Concepts of Comm. Abstrations}
		\begin{frame}[fragile]{General Concepts of Comm. Abstrations}
			\begin{itemize}
				\item Master core \textbf{cannot be blocked}
				\item Communication Interfaces export \textbf{only asynchronous calls}
				\item \textbf{Lazy transfer}
			\end{itemize}

			\begin{itemize}
				\item \textbf{Naming Convention}
				\begin{itemize}
					\item Sender Role: \texttt{open}/\texttt{close}/\texttt{awrite/signal}/\texttt{wait}.
					\item Receiver Role: \texttt{create}/\texttt{unlink}/\texttt{aread}/\texttt{wait}
				\end{itemize}
			\end{itemize}

			% Como bloquear o mestre introduziria um grande problema de performance no nível do microkernel.
			% Todas as interfaces exportam apenas operações assíncronas.
			% Porém, deviado a limitação no uso da DMA, foi introduzido o conceito de envio preguiçoso.
			% Onde caso o mestre não possua autorização para enviar os dados, ele guarda os parâmetros da operação nas estruturas do SO e continua atendendo requisitações.
			% Ao ser notificado da permissão, ele transfere, de fato os dados.

			% Outro ponto comum das abstrações, é a padronização dos papeis de emissor e receptor.
			% Onde o emissor utiliza funções nomeados com open, close, entre outras.
			% E o receptor utiliza create/unlink, etc.
			% Apenas o wait é compartilhado.

		\end{frame}

		% \pholder[Concept]{Sync Abstration Concept}
		\begin{frame}[fragile]{Sync Abstration}
			\begin{overprint}
			\only<1>{
				\begin{itemize}
					\item Provides cluster synchronization across \textbf{distributed barriers}
					\item Analogous to \textbf{POSIX Signals}
					\item Two modes
					\begin{itemize}
						\item \textbf{\texttt{ALL\_TO\_ONE}}
						\item \texttt{ONE\_TO\_ALL}
					\end{itemize}
				\end{itemize}
				\addfig[][width=.6\linewidth]{imgs/sync-all-to-one.pdf}
			}
			\only<2>{
				\begin{itemize}
					\item Provides cluster synchronization across \textbf{distributed barriers}
					\item Analogous to \textbf{POSIX Signals}
					\item Two modes
					\begin{itemize}
						\item \texttt{ALL\_TO\_ONE}
						\item \textbf{\texttt{ONE\_TO\_ALL}}
					\end{itemize}
				\end{itemize}
				\addfig[][width=.6\linewidth]{imgs/sync-one-to-all.pdf}
			}
		\end{overprint}

			% A abstração de sincronização provê a criação de barreiras distribuídas.
			% Ela é analoga a POSIX Signals e possui dois modos de operação.
			% O primeiro, ALL_TO_ONE, define que o mestre da operação deve aguardar N notificações de N escravos.
			% De forma contrária, ONE_TO_ALL, é o mestre que emite N notificações, liberando cada um dos escravos.
		\end{frame}

		% \pholder[Implementation]{Sync Abstration Implementation}
		\begin{frame}[fragile]{Sync Abstration Implementation}
			\begin{itemize}
				\item Parameters required
				\begin{itemize}
					\item Node list
					\item List size
					\item Mode
				\end{itemize}
				\item Master node must be the first on the list
				\item RX resources related to the Master ID
			\end{itemize}

			\addfig[][width=.6\linewidth]{imgs/sync-all-to-one.pdf}

			% Os parametros para criar ou abrir um sync são os mesmos para ambos os papéis.
			% No qual a lista de nós envolvidos deve sempre conter o mestre da operação na primeira posição.
			% Na DMA, é alocado o recurso associado ao identificador do mestre e configurado com os nós da lista.
		\end{frame}

		% \pholder[Concept]{Mailbox Abstration Concept}
		\begin{frame}[fragile]{Mailbox Abstration}
			\begin{itemize}
				\item Allows exchange \textbf{fixed-length message}
				\item Similarly to \textbf{POSIX Message Queue}
				\item Receiver allocates space to N messages
				\item Sender transfer to predefined location
			\end{itemize}

			\addfig[][width=.4\linewidth]{mailbox-concept.pdf}		
	
			% A mailbox permite que clusters troquem mensagens de tamanho fixo.
			% Ela é similar ao POSIX Message Queue, onde o receptor aloca espaço suficiente para receber N mensagens.
			% Já os emissores, sempre transferem para uma localização pré-determinada.
		\end{frame}

		% \pholder[Implementation]{Mailbox Abstration Implementation}
		\begin{frame}[fragile]{Mailbox Abstration Implementation}
			\begin{itemize}
				\item Message queue allocated within the kernel space
				\item \textbf{Quality of Service}
				\begin{itemize}
					\item \textbf{One message} per NoC Node
				\end{itemize}
				\item Parameters required
				\begin{itemize}
					\item \textit{Create}: Local ID
					\item \textit{Open}: Target ID
					\item \textit{Read/Write}: Pointer and size of the buffer
				\end{itemize}
			\end{itemize}

			\addfig[][width=.75\linewidth]{mailbox-flow.pdf}

			% A fila de mensagens é alocada dentro do kernel para que o usuário não precise configurar um buffer previamente.
			% A mailbox também provê um controle de fluxo, permitindo que cada nós só envie uma mensagem de cada vez.
			% Os parâmetros necessário envolvem identificar a interface da qual desejam ler ou enviar dados.
			
			% %%%%%A leitura e envio ocorrem através da passagem do buffer contendo a mensagem.
		\end{frame}

		% \pholder[Concept]{Portal Abstration Concept}
		\begin{frame}[fragile]{Portal Abstration}
			\begin{itemize}
				\item Allows exchange \textbf{arbitrary amounts of data} between two nodes
				\item Similarly to \textbf{POSIX Pipes}
				\item \textbf{One-way} channel for data transfer
			\end{itemize}

			\addfig[][width=.4\linewidth]{portal-concept.pdf}

			% O portal permite a troca de quantidade arbitrárias de dados entre 2 nós.
			% Similar ao POSIX pipes, a comunicação é unidirecional, ou seja, apenas um envia e o outro lê.
		\end{frame}

		% \pholder[Implementation]{Portal Abstration Implementation}
		\begin{frame}[fragile]{Portal Abstration Implementation}
			\begin{itemize}
				\item No intermediate copies
				\item \textbf{Quality of Service}
				\begin{itemize}
					\item \textit{Receiver notifies sender} that it is able to receive
				\end{itemize}
				\item Parameters required
				\begin{itemize}
					\item \textit{Create}: Local ID, \textit{Allow}: Target ID
					\item \textit{Open}: Local and target ID
					\item \textit{Read/Write}: Pointer and size of the buffer
				\end{itemize}
			\end{itemize}

			\addfig[][width=.75\linewidth]{portal-flow.pdf}

			% A configuração das comunicações do portal não necessitam de copias intermediárias.
			% Ou seja, os dados são lidas/escritos diretamente da memória do usuário.
			% Isto é possível por causa do controle de fluxo do portal.
			% O qual o receptor precisa notificar o emissor que está apto a receber os dados.
			% Os parâmetros são similares aos visto no mailbox, com diferença da função Allow da interface do receptor.
		\end{frame}

	\subsection{User-Level Communication}

		\begin{frame}[fragile]{Integration with Nanvix Microkernel}
			\begin{itemize}
				\item Nanvix HAL does not provide \textbf{rich management} of the exposed abstractions
				\item Nanvix Microkernel seek \textbf{to provide Inter-Process Communication} between clusters
				\begin{itemize}
					\item Protection
					\item Management
					\item Manipulating
				\end{itemize}
			\end{itemize}

			% The inter-cluster communication module, described in \autoref{sec.low-level-comm},
			% is designed to export a standard and straightforward communication
			% primitives to different lightweight manycores.
			% These primitives can be used by various types of \oss and applications.
			% Thus, the module is flexible enough not to impact the performance
			% of the upper layers negatively.
			% For this, it does not provide rich management of the exposed abstractions.

			% In this scenario, the communication services of \nanvixmicrokernel seek
			% to provide \ipc between distinct clusters.
			% Specifically, these services perform the multiplexing of the hardware
			% resources and the verification of the parameters that will be passed
			% on the communication primitives.
			% Due to the Master-Slave model, the master core is responsible of protecting,
			% manipulating, and configuring \hal resources.
			% The slave core will request operations through the kernel call interface,
			% passing the necessary information to the master.
		\end{frame}

		% \pholder{Impacts of the Master-Slave Model}
		\begin{frame}[fragile]{Impacts of the Master-Slave Model}
			\begin{itemize}
				\item Only the master core manipulates internal structures of the OS
				\item Kernel call interface
				\begin{itemize}
					\item Master calls: \texttt{kernel\_\textit{abstraction}\_\textit{operation}}
					\item Slave calls: \texttt{k\textit{abstraction}\_\textit{operation}}
				\end{itemize}
				\item Slave only reads locks address from internal structures to block
			\end{itemize}

			% Master-Slave model defines that the master core must exclusively manipulate
			% the internal structures of the \os. For this end, each service has generic and
			% simple structures that hold control flags, parameters for resource
			% identification, and storage of physical descriptors returned by \hal. Thus,
			% the kernel call interface separates the functions of the services into two
			% sets of functions. The first set contains the kernel calls that request a particular
			% operation. The second set contains functions that operate on the internal structures
			% and communicate with the \hal level. The master executes almost exclusive
			% the second set, except for the wait functions, which the slave performs entirely.
		\end{frame}

		% \pholder[Protection and Management, Multiplexing, Validation and Correctness Tests]{Details}
		\begin{frame}[fragile]{Protection and Management}
			\begin{itemize}
				\item Protection and management operations involve \textbf{two phases}
				\item \textbf{Slave phase}
				\begin{itemize}
					\item valid file descriptors
					\item non-null buffer pointers
					\item buffer sizes within the stipulated limit
					\item semantics of services
				\end{itemize}
				\item \textbf{Master phase}
				\begin{itemize}
					\item multiple creations/openings
					\item conflicting operations
					\item measures communication parameters
					\item interacts with Nanvix HAL detecting errors
				\end{itemize}
			\end{itemize}
		\end{frame}

		\begin{frame}[fragile]{Multiplexing}
			\begin{itemize}
				\item Identifies creations/openings with \textbf{same arguments}
				\item Structures keep a \textbf{reference counter}
				\item Operations of read/write set resources \textbf{to busy}
				\item Forces \textbf{serialization} of the operations
			\end{itemize}

			% The identification of creations/openings with the same arguments
			% allows multiple slaves to use the same resource at different times.
			% For this, the internal structures of the \os keep, as simply as possible,
			% the arguments used to create/open a service. When the same arguments are
			% identified, a reference counter is incremented. The master sets the resource
			% to busy when prompted for a read/write. A second slave who wants to read/write
			%  will be prevented until the previous operation is completed. The resources
			%  of the \hal will only be released when all references are removed.
		\end{frame}

		\begin{frame}[fragile]{Validation and Correctness Tests}
			\begin{itemize}
				\item \textbf{API tests}
				\begin{itemize}
					\item Arguments within valid value ranges
					\item Operations with valid semantic
				\end{itemize}
				\item \textbf{FAULT tests}
				\begin{itemize}
					\item Arguments outside domain range
					\item Operations with invalid semantic
					\item Expected error value
				\end{itemize}
			\end{itemize}

			% Validation and correctness testing of the implementation of services was
			% performed through two sets of unit tests, \textit{API} and \textit{FAULT}
			% tests, respectively. On the one hand, \textit{API} tests create, open, and
			% stimulate services with arguments within valid value ranges. On the other
			% hand, \textit{FAULT} tests use arguments outside the domain range of the
			% operations. The failure should generate a previously known error value.
			% The tests validate any changes made by verifying all expected behaviors
			% of each service.
		\end{frame}

% LocalWords:  template cls standalone GitHub Overleaf bugfixes SVGs
% LocalWords:  Re-empacotamento fontsize Makefile pdflatex imgs PDFs
% LocalWords:  shell-escape frames SVG brazil english lapesd-slides
% LocalWords:  disabletodonotes todonotes TODO's backup showbackup
% LocalWords:  hidebackup abntexcite abntex natbib nobib titleframe
% LocalWords:  frame showsections sidebar stopcountingframes default
% LocalWords:  thanksframe Thank You Questions referencesframe titulo
% LocalWords:  bibfiles pholder todonote placeholder inline addfig
% LocalWords:  opts graphicx addfiglw width Citations dijkstra Direct
% LocalWords:  Closure Parallel dynamic scheduling DoImportantStuff
% LocalWords:  lccp merged cell svg pdf
